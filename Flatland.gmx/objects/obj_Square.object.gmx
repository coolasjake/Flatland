<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_square</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize variables.
dir = 90
a = 45
d = 50
strafe = 0
foolean = 0
no_collision = 1
spd = 1
c_count = 2
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pretty much all of the code. :)
//move forward
A = degtorad(dir)
if keyboard_check(vk_left) and keyboard_check(vk_rcontrol)
{
    if !place_meeting(x+sin(A)*-(2*spd),y-cos(A)*-(2*spd),obj_Equilateral) and !place_meeting(x+sin(A)*-(2*spd),y-cos(A)*-(2*spd),obj_Isoscolese) 
    {
        y-= cos(A)*-(2*spd)
        x+= sin(A)*-(2*spd)
    }
}
else if keyboard_check(vk_left)
{
    dir += (1*spd)
    if !keyboard_check(vk_up) and !keyboard_check(vk_down) and !keyboard_check(vk_rcontrol)
    {
        dir += (1*spd)
    }
}

A = degtorad(dir)
if keyboard_check(vk_right) and keyboard_check(vk_rcontrol)
{
    if !place_meeting(x+sin(A)*(2*spd),y-cos(A)*(2*spd),obj_Equilateral) and !place_meeting(x+sin(A)*(2*spd),y-cos(A)*(2*spd),obj_Isoscolese)
    {
        y-= cos(A)*(2*spd)
        x+= sin(A)*(2*spd)
    }
}
else if keyboard_check(vk_right)
{
    dir -= (1*spd)
    if !keyboard_check(vk_up) and !keyboard_check(vk_down) and !keyboard_check(vk_rcontrol)
    {
        dir -= (1*spd)
    }
}

A = degtorad(dir)

if keyboard_check(vk_up) and !keyboard_check(vk_down)
{
    if !place_meeting(x+cos(A)*(2*spd),y-sin(A)*(2*spd),obj_Equilateral) and !place_meeting(x+cos(A)*(2*spd),y-sin(A)*(2*spd),obj_Isoscolese)
    {
        y-= sin(A)*(2*spd)
        x+= cos(A)*(2*spd)
    }
}
else if keyboard_check(vk_down)
{
    if !place_meeting(x+cos(A)*-(2*spd),y-sin(A)*-(2*spd),obj_Equilateral) and !place_meeting(x+cos(A)*-(2*spd),y-sin(A)*-(2*spd),obj_Isoscolese)
    {
        y-= sin(A)*-(2*spd)
        x+= cos(A)*-(2*spd)
    }
}


//Start of rendering
if c_count &lt; 2 {c_count += 1}
else
{
Distance = 1
Angle = 0
for (Angle=0; Angle&lt;=360; Angle+=1)
{
Angles[Angle,0] = 0
Angles[Angle,1] = 1
}

ID = instance_nearest(x,y,obj_Equilateral)
ID2 = instance_nearest(x,y,obj_Isoscolese)
if point_distance(x, y, ID.x, ID.y) &gt; 140 and point_distance(x, y, ID2.x, ID2.y) &gt; 140 {exit}



no_collision = 1
//Start of Efficient block. !?!?!?!?!?!?!?!?!?!
for (Angle=strafe; Angle&lt;=(360); Angle+=16)
{
    for (Distance=1; Distance&lt;=400; Distance+=8)
    {
        A = degtorad(dir-45+(Angle/4))
        
        if Angles[Angle,0] = 0
        {
            Angles[Angle,0] = scr_Check_Collisions(x,y,A,Distance)
            if !Angles[Angle,0] = 0 
            {
            Angles[Angle,1] = Distance
            foolean = 2
            no_collision = 0
            }
        }
    }
    
    if foolean &gt; 0 and Angle &gt;= 16
    {
    for (Detail_Angle=(Angle-16); Detail_Angle&lt;Angle; Detail_Angle+=4)
    {
    for (Distance=1; Distance&lt;=400; Distance+=2)
    {
        A = degtorad(dir-45+(Detail_Angle/4))
        
        if Angles[Detail_Angle,0] = 0
        {
            Angles[Detail_Angle,0] = scr_Check_Collisions(x,y,A,Distance)
            if !Angles[Detail_Angle,0] = 0 
            {
            Angles[Detail_Angle,1] = Distance
            foolean = 2
            no_collision = 0
            }
        }
    }
    }
    foolean -= 1
    }
}
if strafe = 15 and no_collision = 1 {strafe = 0}
else if no_collision = 1 {strafe += 1}
//End of Efficient block. !?!?!?!?!?!?!?!?!?!

c_count = 0
}


/*
if a &gt; 135
{
a = 45
if d &gt; 99 {d = 50}
else {d += 1}
}
else {a += 1}

A = degtorad(a)

obj_Equilateral.y = y-sin(A)*d
obj_Equilateral.x = x+cos(A)*d+16
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///The rest of the code.
draw_sprite_ext(spr_square,0,x,y,1,1,dir,c_white,1)

for (Angle=0; Angle&lt;360; Angle+=1)
{

    draw_set_colour(c_white)
    if Angles[Angle,0] = 0 {}
    /*{
        //draw_rectangle_colour(Angle*2,0,Angle*2+4,room_height, col1, col2, col3, col4, outline)
        draw_set_colour(c_white)
        draw_set_alpha((100-Angles[Angle,1])/100)
        //draw_line(Angle*2,0,Angle*2+4,room_height)
        draw_rectangle(Angle*2,0,Angle*2+4,room_height,0)
    }*/
    else if Angles[Angle,0] = 1
    {
        draw_set_colour(c_black)
        draw_set_alpha((400-Angles[Angle,1])/400)
        //draw_line(Angle*2,0,Angle*2+4,room_height)
        draw_rectangle((360-Angle)*2,0,(360-Angle)*2+7,room_height,0)
    }
    else if Angles[Angle,0] = 2
    {
        draw_set_colour(c_aqua)
        draw_set_alpha((400-Angles[Angle,1])/400)
        //draw_line(Angle*2,0,Angle*2+4,room_height)
        draw_rectangle((360-Angle)*2,0,(360-Angle)*2+7,room_height,0)
    }
    else if Angles[Angle,0] = 3
    {
        draw_set_colour(c_blue)
        draw_set_alpha((400-Angles[Angle,1])/400)
        //draw_line(Angle*2,0,Angle*2+4,room_height)
        draw_rectangle((360-Angle)*2,0,(360-Angle)*2+7,room_height,0)
    }
    else if Angles[Angle,0] = 4
    {
        draw_set_colour(c_red)
        draw_set_alpha((400-Angles[Angle,1])/400)
        //draw_line(Angle*2,0,Angle*2+4,room_height)
        draw_rectangle((360-Angle)*2,0,(360-Angle)*2+7,room_height,0)
    }
}

for (Angle=0; Angle&lt;=90; Angle+=1)
{
    A = degtorad(dir-45+Angle)
    draw_set_colour(c_orange)
    draw_set_alpha(0.5)
    draw_line(x,y,x+cos(A)*400,y-sin(A)*400)
    
}

draw_set_alpha(1)
draw_set_colour(c_gray)
draw_rectangle(359,(room_height/2)+8,361,(room_height/2)-8, 0)
draw_rectangle(368,(room_height/2)+1,352,(room_height/2)-1, 0)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
